* protocol_client
- sampler
- sending non blocking
 - DMA: not yet. Use a sendComplete Interrupt
- use CRC hardware (twice, header and payload)

- Later
- DMA to serial
- test CRC hardware performance vs on cpu


* Misc Notes
** Client Architecture
Reading: do everything in interrupt, nak/ack
** Layers:
| App: Embedded / Client |
| Protocol               |
|                        |

* Testing at large
how do I manage the tests.
+ tests subdirectory for all tests, just for ordering
+ test_library.py
  + contains low level tests of emolog
+ test_protocol_roundtrip.py
  + bad name?
  + contains tests of the
+ embeddedsimulator.py - what was I thinking? srsly, what is it exactly? asyncio tester, it should do what the rountrip is, Step A.

* session TODO
+ [x] --varfile <filename> which parses just like consecutive --var parameters
+ [x] take float/int from ELF
+ [x] use full_name
+ [x] remove extra empty lines in CSV
+ [x] float convertion not working
+ why do we get sometimes 0 vars, sometimes 1, sometimes 2 (reruns with embedded not reset in between)
+ exit after fixed time implementation
+ key press to exit instead of ctrl-c
+ default phase 0 if --var a,b,c ; default rate 1 if --var a,b

* Integration testing
- Step A: Python embedded implementation [2/3]
  - [X] Write python client to embedded communication [2/2]
    - [X] Write Embedded protocol application layer
    - [X] Fix FakeSineEmbedded
      - it registers a transport which is a pipe
      - handles the messages
      - produces samples of sines
  - [X] Python tester, automated, no GUI
  - [ ] Python GUI with python sine embedded
  - will just return a sinus for every registered variable, with rising frequency
  - The source can say whatever it wants (source being the client figuring out the addresses)
  - Enables writing the full GUI to show these sinuses, uses the real protocol so guranteed to work later.
  - Just possible problems:
    - ELF parser incorrect, addresses are wrong - we can debug with TI debugger

- Possible middle step: Use a C program compiled to ELF but on the PC
  - enables debugging without hardware
  - can use the real ELF parser
  - Possible problems:
    - ELF DWARF info generated by gcc for x64 not the same as that generated by TI compiler for ARM

Step B: test with a TI application
- use a C program compiled for the TI running on the TI
- same as production software, just a toy program
- uses the same compiler, same protocol
- can check actual speed. Attempt to raise the speed to see the limit

* Client changelist [0/1]
** TODO only work with asyncio and protocols. Since I know it works with serial + qt, and at worst for serial I can introduce a subprocess (asyncio works fine with that under windows with proactor)
** 
